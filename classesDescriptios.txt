Классы и объекты
Понятия класса и объекта являются ключевыми в объектно-ориентированных языках программирования,
к которым относится также и язык python. В нем ВСЁ является ОБЪЕКТАМИ –
и строки,
и списки,
и словари,
и функции,
и даже САМИ КЛАССЫ.

Объект есть любая сущность в python (функция, число, строка… всё).
Класс это объект, чьим типом является type (тип можно подсмотреть в атрибуте __class__).
Экземпляр некоторого класса A — это объект, у которого в атрибуте __class__ есть ссылка
на класс A.

Класс (от англ. class) – это шаблон кода, который используется для описания структуры и
создания объектов, т.е. экземпляров этого класса.
Классы в python представляют собой типы данных, а объекты – отдельные экземпляры этих типов.
Например, в инструкциях a = 'abcdef' и b = 'ABCDEF' переменным a и b присваиваются объекты
строкового типа данных, т.е. экземпляры встроенного класса string.

Класс можно сравнивать с чертежом, по которому создаются объекты.
Достаточно создать всего лишь один класс и далее можно будет порождать любое количество
его экземпляров (объектов), изменяя и дополняя их по мере необходимости.

Благодаря применению классов python обладает всеми преимуществами абстрактного подхода в
программировании. В частности Питону присущи:

Полиморфизм (от англ. polymorphism) – способность функций и методов обрабатывать данные
    разных типов. Примерами полиморфизма могут служить: встроенная функция len(s), которая
    может работать с разными типами встроенных последовательностей и возвращая количество
    их элементов; метод s.count(x), который подсчитывает количество символов x в строке s
    (один тип данных) или, например, количество элементов x в списке s (другой тип данных);
    операторы сложения и умножения, которые для чисел (один тип данных) производят операции
    сложения и умножения, а для строк (другой тип данных) конкатенацию и повторение
    конкатенации указанное число раз.
Инкапсуляция (от англ. encapsulation) – механизм, который позволяет объединять данные и
    методы, работающие с этими данными, в единый объект, скрывая при этом детали реализации
    от пользователя. Грамотно (!!!) написанный класс должен ограничивать  доступность своих
    членов и взаимодействовать с пользователем только с помощью своего интерфейса.
    При важно, что инкапсуляция в python работает только на
    УРОВНЕ СОГЛАШЕНИЯ между ПРОГРАММИСТАМИ о том, какие атрибуты следует считать
    общедоступными, а какие – приватными (подробнее об этом далее).
Наследование (от англ. inheritance) – концепция объектно-ориентированного программирования,
    которая позволяет на основе одного класса (суперкласса) создавать множественные подклассы,
    заимствующие его данные и функциональность с возможностью их изменения и добавления своих
    данных и функциональности. При этом в python поддерживается возможность множественного
    наследования, когда подкласс наследует атрибуты сразу нескольких суперклассов
    одновременно. Таким образом, наследование способствует повторному использованию уже
    написанных компонентов программы, помогая избежать избыточности исходного кода.
Композиция (агрегирование) (от англ. composition) – возможность создания классов, включающих
    в себя вызовы уже существующих классов. В результате при создании объектов такого класса
    они будут состоять или содержать объекты других классов. Важно не путать композицию с
    наследованием, в том числе множественным: при наследовании подкласс получает все атрибуты
    (т.е. возможности) своих суперклассов, а при композиции класс-агрегатор атрибуты
    не наследует, он просто создает объекты этих классов для использования, например,
    в качестве своих атрибутов или локальных переменных своих методов.

Благодаря всем этим преимуществам ООП у программистов появляется возможность параллельной
разработки отдельных независимых модулей в виде классов, способных скрывать от
внешнего мира (!!!) детали своего внутреннего устройства и объединяющихся в масштабные
комплексные приложения посредством предназначенных для этого интерфейсов.

Объявление классов и создание объектов
python — 'динамический' язык. Переменные (которые правильнее было бы называть идентификаторами)
не нужно объявлять и они могут быть добавлены как атрибуты (атрибуты класса и объекта)
в любом месте кода.

Для объявления классов в python используется инструкция class, которая в общем виде может быть
представлена в следующем формате:

class ClassName(SuperclassName_1, ..., SuperclassName_n):
    '''Документация класса ClassName.__doc__'''
    # Атрибут данных класса (доступен всем экземплярам).
    class_data = class_value

    # Конструктор класса (инициализация экземпляра).
    def __init__(self, init_arg_1, init_arg_2, ..., init_arg_n):

        # Атрибут данных конкретного экземпляра.
        self.init_obj_data = init_obj_value

    # Атрибут-метод (доступен всем экземплярам).
    def class_method(self, arg_1, arg_2, ..., arg_n):

        # Атрибут данных конкретного экземпляра.
        self.obj_data = obj_value

В заголовке инструкции сперва записывается служебное слово class, затем через пробел
указывается имя класса, которое по принятому в python соглашению обычно записывается в
нотации CupWords, далее в скобках перечисляются имена наследуемых классов
(их еще называют суперклассами) и завершается заголовок двоеточием.
Если создаваемый класс не наследует других классов, заголовок инструкции записывается
в формате class ClassName:

(опускаются круглые скобки и записывается двоеточие сразу после имени класса) - это означает,
что объявляемый класс НЕ ЯВЛЯЕТСЯ классом-наследником базовых класса.
В любом случае после заголовка записывается вложенный блок инструкций, в котором перечисляются
атрибуты данных класса (по умолчанию они доступны для использования всеми создаваемыми
объектами экземплярами класса) и атрибуты-методы для обработки его данных, представляющие собой
функции, определенные внутри класса и принимающие в качестве первого аргумента параметр self,
которому при вызове методов интерпретатор автоматически присваивает ссылку на текущий экземпляр
(объект) класса. При необходимости в начале тела класса рнкомендуется указывать строку
(строки) документирования класса.
В классе объявляется конструктор класса со стандартным именем __init__().
Он представляет собой специальный метод класса, который вызывается автоматически всякий раз
при создании нового объекта (экземпляра), инициализируя его исходными данными.
Изменение имени конструктора запрещено (!!!).

После определения класса, возможно создание его отдельных объектов (экземпляров), сохраняя
их в переменных или структурах данных. Для этого нужно после имени класса указать в круглых
скобках, перечислив в них начальные данные для инициализации создаваемого объекта экземпляра.

# Пример №01. Объявление пустого класса:
class MyClass:
    pass

# В любом месте программы через класс можно создать атрибут:

MyClass.class_attribute = 759

# Теперь у класса есть атрибут class_attribute. Это можно проверить через
"инстанциирование" (создание объекта -представителя) класса:

my_object = MyClass()
print(my_object.class_attribute)
# 759

# Также возможно создать атрибут НЕ ДЛЯ КЛАССА, А ДЛЯ КОНКРЕТНОГО ОБЪЕКТА-ПРЕДСТАВИТЕЛЯ
# данного класса:

my_object.instance_attribute = 29
print(my_object.instance_attribute)
# 29

Каким образом в Python хранятся атрибуты
Атрибуты в Python хранятся в 'магическом' атрибуте __dict__.
К нему можно получить доступ:

class MyClass:
    class_attribute = "Class"
    def __init__(self):
        self.instance_attribute = "Instance"
my_object = MyClass()
print(my_object.__dict__)
print(MyClass.__dict__)

"""
атрибуты объекта
{'instance_attribute': 'Instance'}

атрибуты класса
{'__module__': '__main__',
 'class_attribute': 'Class',
 '__init__': <function MyClass.__init__ at 0x7f57d910d280>,
 '__dict__': <attribute '__dict__' of 'MyClass' objects>,
 '__weakref__': <attribute '__weakref__' of 'MyClass' objects>,
 '__doc__': None}
"""
class_attribute хранится в словаре всего класса, а instance_attribute хранится для объекта.
Действительно, конструктор создается именно для объекта.
Это означает, что всё в python имеет атрибут __dict__, включая классы и функции.
Кроме того, важно, что всё в python (в том числе и объявление ккласса) — это объект,
к которому можно обращаться.

__dict__ - это атрибут. И он 'ведёт себя' так же, как и все атрибуты в python.

Изменяемые переменные на примере списка:

class AddressBook:
    addresses = []

Создаются несколько экземпляров этого класса и заполняется список. Код на python:

alices = AddressBook()
alices.addresses.append(("Sherlock Holmes", "221B Baker St., London"))
alices.addresses.append(("Al Bundy", "9764 Jeopardy Lane, Chicago, Illinois"))

bobs = AddressBook()
bobs.addresses.append(("Bart Simpson", "742 Evergreen Terrace, Springfield, USA"))
bobs.addresses.append(("Hercule Poirot", "Apt. 56B, Whitehaven"))

Теперь эти объекты делят один список на двоих:

>>> alices_address_book.addresses
[('Sherlock Holmes', '221B Baker St., London'),
 ('Al Bundy', '9764 Jeopardy Lane, Chicago, Illinois'),
 ('Bart Simpson', '742 Evergreen Terrace, Springfield, USA'),
 ('Hercule Poirot', 'Apt. 56B, Whitehaven')]

>>> bobs_address_book.addresses
[('Sherlock Holmes', '221B Baker St., London'),
 ('Al Bundy', '9764 Jeopardy Lane, Chicago, Illinois'),
 ('Bart Simpson', '742 Evergreen Terrace, Springfield, USA'),
 ('Hercule Poirot', 'Apt. 56B, Whitehaven')]

Это происходит потому, что список определен на уровне класса.
Пустой список создается только один раз: в тот момент когда интерпретатор
СОЗДАЁТ КЛАСС AddressBook. Этот список является изменяемым объектом (mutable).

Также можно создавать список на уровне экземпляра класса (объекта), добавив его в конструктор:

class AddressBook:
    def __init__(self):
        self.addresses = []

Теперь список будет создаваться в момент создания объекта, т.е. когда создается экземпляр
класса AddressBook.

# Пример №1. Создание классов и объектов в python.
# Определяем обычный класс (не наследует других классов).
class Person:
    '''Компания "Okpython" и ее сотрудники.'''
    # Создаем атрибут данных класса (доступен всем экземплярам).
    company = 'Okpython'

    # Конструктор класса инициализирует объект начальными данными.
    # Атрибуту name присваивается значение по умолчанию
    def __init__(self, name='Alex'):
        # Создание атрибута данных объекта экземпляра.
        self.name = name

    # Определяется 1-й метод (self - указатель на текущий объект).
    def set_date(self, date):
        # Создаётся еще один атрибут данных объекта.
        self.date = date

    # Определяется 2-й метод.
    def get_date(self):
        # Используется атрибут данных объекта.
        return self.date

# Создётся 1-й экземпляр класса.
person_1 =  Person('Nick')
# Извлекаем имя сотрудника.
name_1 = person_1.name
# Устанавливаеnся дата начала работы в компании.
# Можно и так: person_1.date = '30.05.2022'.
person_1.set_date('30.05.2022')
# Извлекается дата для использования.
# Можно и так: date_1 = person_1.date
date_1 = person_1.get_date()

# Для 2-го объекта используется имя по умолчанию.
person_2 =  Person()
# Извлекася имя сотрудника.
name_2 = person_2.name
# Устанавливатся дата начала работы в компании.
# Можно и так: person_2.date = '07.03.2021'.
person_2.set_date('07.03.2021')
# Извлекается дату для использования.
# Можно и так: date_2 = person_2.date
date_2 = person_2.get_date()

# Извлекается название компании из объекта класса ('OkPython').
# Можно и так: person_1.company или person_2.company.
company = Person.company
# Выводится на экран документация класса.
print(Person.__doc__, end='\n\n')

# Выводятся данные на экран.
print('В компании', company, 'работают:')
print(name_1, 'с', date_1)
print(name_2, 'с', date_2)


В рассмотренном примере был создан класс Person, в котором не наследется никаких других классов,
поэтому круглые скобки в заголовке были опущены (class Person:). В качестве строки документации
указана обычная строка в тройных одинарных кавычках, после чего был объявлен атрибут данных
класса, которому было присвоено компании (company = 'Okpython').
Этот атрибут стал доступен как из любого объекта класса (person_1.company или person_2.company),
так и напрямую из объекта САМОГО КЛАССА (Person.company).

Далее был определен конструктор класса (def __init__(self, name='Alex'):), который затем
при создании экземпляров (объектов) класса запустился в автоматическом режиме и создал
атрибуты данных создаваемых объектов
(это атрибуты созданных объектов person_1.name и person_2.name).
Важно, что наличие в определении класса конструктора с параметрами влечет за собой
необходимость в передаче вновь создаваемым объектам начальных данных для их инициализации,
иначе будет получена ошибка (в качесте альтернативы можно использовать аргумент со значением
по умолчанию).
В конце объявления класса были добавлены еще два метода для установки и получения атрибута
данных объектов класса

def set_date(self, date):
 .....
 и
def get_date(self):).....

В качестве первого аргумента у методов был задан параметр self, которому при каждом вызове
этих методов интерпретатор автоматически присваивает ссылки на текущие объекты ранее
объявленного класса (то есть объекты person_1 и person_2).

После объявления класса Person создаётся первый экземпляр этого класса,
с использованием инструкции вызова конструктора объекта класса
person_1 = Person('Alex')
и указывается в качестве начальных данных для конструктора значение аргумента по умолчанию
'Alex'.
Для доступа к атрибутам созданного объекта используется "синтаксис с точкой", который
позволяет сохранить в переменной глобальной области видимости имя сотрудника
(name_1 = person_1.name), а также установить и затем также сохранить в переменной дату
трудоустройства сотрудника в компанию инструкции
person_1.set_date('30.05.2022')
и
date_1 = person_1.get_date()).

При выполнении тех же действий для второго объекта, в глобальной переменной с использованием
атрибута данных класса (company = Person.company) сохраняются название компании,
а затем на экран выводится строка документирования класса и данные сотрудников.

Таким образом, процедура создания класса в простейшем случае сводится к объявлению
имени класса ClassName в заголовке инструкции class и перечислению в теле класса его
атрибутов, состоящих из атрибутов данных и атрибутов-методов.

Создание объектов класса, аналогично вызову обычной функции, то есть при помощи пары
круглых скобок после имени класса в формате ClassName(arg_1, arg_2, ... arg_n).
После создания объекта класса можно начинать пользоваться объявленными атрибутами:
получать к ним доступ,
изменять,
удалять или же
добавлять новые атрибуты.

Доступ к атрибутам классов и объектов
Доступ к открытому атрибуту вне класса или объекта может быть получен с помощью имени
этого атрибута, указанного через точку после имени класса или объекта в формате obj.attr.
Для добавления нового атрибута или изменения значения уже существующего используется
инструкция присваивания obj.new_attr = value или, соответственно, obj.attr = new_value,
а удаление осуществляется инструкцией del obj.attr.
По умолчанию все атрибуты и методы класса являются ОТКРЫТЫМИ или ПУБЛИЧНЫМИ (от англ. public).
Это значит, что они доступны не только внутри класса, но и за его пределами.
Для этого достаточно использовать синтаксис доступа к атрибутам при помощи точки
(например, obj.attr) или предназначенные для этого встроенные функции
(например, getattr(obj, 'attr')).

Но также бывают случаи, когда требуется ограничить прямой доступ к атрибутам классов из
вызывающего кода во избежание передачи им некорректных значений или случайного удаления.
Примером может служить площадь земельного участка, который не может быть отрицательным,
или значение атрибута, предназначенного для "служебного" пользования.
В таких случаях атрибуты объявляются закрытыми или приватными (от англ. private),
предоставляя доступ к ним посредством интерфейсов взаимодействия в виде специальных методов,
осуществляющих необходимые проверки передаваемых им значений.
При этом важно, что в python инкапсуляция в классах (т.е. сокрытие данных) поддерживается лишь
НА УРОВНЕ СОГЛАШЕНИЯ МЕЖДУ ПРОГРАММИСТАМИ. Полностью скрыть реализацию класса от преднамеренных
действий извне не получится(!!!).
Атрибуты, предназначенные для внутреннего использования, принято начинать с одного символа
подчеркивания (например, _var). Встретив такой атрибут, ДРУГОЙ (???) программист (!!!)
будет иметь в виду, что он не предназначен для публичного использования и в дальнейшем может
быть даже удален без предварительного уведомления. В тоже время НИКТО НЕ ЗАПРЕЩАЕТ (!!!)
изменять такой атрибут на свой страх и риск (!!!), надеясь, что это не повлияет на
работоспособность класса.


# Пример №2. Атрибуты классов и объектов в python (часть 1).
# Создаётся простой класс.
class ExampleClass:
    # Устанавливаются атрибуты данных экземпляра.
    def __init__(self):
        self.attr_0 = 0.0

# Создаем 1-й экземпляр класса ExampleClass.
obj_1 = ExampleClass()
# Создаем 2-й экземпляр класса ExampleClass.
obj_2 = ExampleClass()

# Выводим значение атрибута данных экземпляра.
print('obj_1.attr_0 ->', obj_1.attr_0)
# Также выведет 0.0.
print('obj_2.attr_0 ->', obj_2.attr_0, end='\n\n')

# Изменяем значение атрибута в 1-м объекте.
obj_1.attr_0 = 1.1
# Выведет 1.1.
print('obj_1.attr_0 ->', obj_1.attr_0)
# Выведет 0.0, т.к. во 2-м объекте атрибут не изменялся.
print('obj_2.attr_0 ->', obj_2.attr_0, end='\n\n')

# Добавляем новый атрибут 1-му экземпляру.
obj_1.attr_1 = 1.2
# Выведет True.
print("hasattr(obj_1, 'attr_1') ->", hasattr(obj_1, 'attr_1'))
# Выведет 1.2.
print('obj_1.attr_1 ->', obj_1.attr_1, end='\n\n')
# Такой атрибут во втором объекте отсутствует.
# 'ExampleClass' object has no attribute 'attr_1'.
# print('obj_2.attr_1 ->', obj_2.attr_1)

# Удаляем атрибут 1-го экземпляра.
del obj_1.attr_1
# Выведет False, т.к. атрибут был удален.
print("hasattr(obj_1, 'attr_1') ->", hasattr(obj_1, 'attr_1'))
# 'ExampleClass' object has no attribute 'attr_1'.
# print('obj_1.attr_1 ->', obj_1.attr_1)

В python нет сокращений для ссылки на атрибуты данных или другие методы ИЗНУТРИ методов.
Это улучшает (!!!) читаемость и создание методов, так как нет возможности путать локальные
переменные и переменные экземпляра при просмотре и создании метода.
Вместо использования привычной точечной нотации для доступа к атрибутам внутри метода
можно использовать встроенные функции:

getattr(obj, name [, default]) - для доступа к атрибуту name объекта класса obj.
hasattr(obj, name) - проверить, есть ли в классе obj атрибут name.
setattr(obj, name, value) - задать атрибут name со значением value.
                            Если атрибут не существует, он будет создан.
delattr(obj, name) - удалить атрибут name из объекта класса obj.

Встроенные атрибуты класса.
Классы Python хранят встроенные атрибуты, к которым можно получить доступ как к любому
другому атрибуту данных.

__dict__ - словарь, содержащий пространство имен класса.
__doc__ - строка документации класса. None если, документация отсутствует.
__name__ - имя класса.
__module__ - имя модуля, в котором определяется класс.
__bases__ - кортеж, содержащий базовые классы, в порядке их появления.
            Кортеж будет пустым, если наследование не было.
__mro__ - Порядок разрешения методов в множественном наследовании.

Где хранятся атрибуты класса и экземпляра класса?
Поведение атрибутов python строго определено и легко (???) настраивается.
Атрибуты в python хранятся в магическом методе с именем __dict__.
Получить доступ к нему можно следующим образом:

class MyClass:
    class_attr = "Class"

    def __init__(self):
        self.instance_attr = "Instance"

my_object = MyClass()
# атрибут экземпляра класса
my_object.__dict__
# {'instance_attribute': 'Instance'}

# атрибут экземпляра класса
MyClass.__dict__['class_attr']
# 'Class'

my_object.class_attr
'Class'
my_object.instance_attr
'Instance'

Помимо синтаксиса с точкой, операции над атрибутами объектов в python могут проводиться и
при помощи предназначенных для этого встроенных функций:

hasattr(object, name) – функция проверяет наличие в объекте object атрибута с именем name,
                        возвращая True в случае успеха и False в противном случае.
                        В качестве аргументов ей передаются объект и строка с именем искомого
                        в нем атрибута.
getattr(object, name[, default]) – возвращает значение атрибута name переданного объекта
                                   object, если он существует. В противном случае функция
                                   возвращает значение по умолчанию default, если оно было
                                   передано, или возбуждает исключение AttributeError.
                                   В качестве обязательных аргументов функции передаются
                                   объект и строка с именем искомого в нем атрибута.
setattr(object, name, value) – устанавливает новое значение value атрибуту с именем name
                               переданного объекта object, если он существует. В противном
                               случае интерпретатор создает новый атрибут с указанным именем
                               и присваивает ему переданное значение. В качестве первых
                               двух аргументов функции передаются объект и строка с именем
                               искомого в нем атрибута.
delattr(object, name) – удаляет из объекта object атрибут с именем name, если объект
                        позволяет это сделать. В качестве аргументов ей передаются объект и
                        строка с именем искомого в нем атрибута.

# Пример №3. Функции для работы с атрибутами классов и объектов.
# Создаем простой класс.
class ExampleClass:
    # Устанавливаем атрибут данных экземпляра.
    def __init__(self):
        setattr(self, 'attr_0', 0.0)

# Создаем 1-й экземпляр класса ExampleClass.
obj_1 = ExampleClass()
# Создаем 2-й экземпляр класса ExampleClass.
obj_2 = ExampleClass()

# Выводим значение атрибута данных экземпляра.
print("getattr(obj_1, 'attr_0') ->", getattr(obj_1, 'attr_0'))
# Также выведет 0.0.
print("getattr(obj_2, 'attr_0') ->", getattr(obj_2, 'attr_0'), end='\n\n')

# Изменяем значение атрибута в 1-м объекте.
setattr(obj_1, 'attr_0', 1.1)
# Выведет 1.1.
print("getattr(obj_1, 'attr_0') ->", getattr(obj_1, 'attr_0'))
# Выведет 0.0, т.к. во 2-м объекте атрибут не изменялся.
print("getattr(obj_2, 'attr_0') ->", getattr(obj_2, 'attr_0'), end='\n\n')

# Добавляем новый атрибут 1-му экземпляру.
setattr(obj_1, 'attr_1', 1.2)
# Выведет True.
print("hasattr(obj_1, 'attr_1') ->", hasattr(obj_1, 'attr_1'))
# Выведет 1.2.
print("getattr(obj_1, 'attr_1') ->", getattr(obj_1, 'attr_1'), end='\n\n')
# Такой атрибут во втором объекте отсутствует.
# 'ExampleClass' object has no attribute 'attr_1'.
# print("getattr(obj_2, 'attr_1') ->", getattr(obj_2, 'attr_1'))

# Удаляем атрибут 1-го экземпляра.
delattr(obj_1, 'attr_1')
# Выведет False, т.к. атрибут был удален.
print("hasattr(obj_1, 'attr_1') ->", hasattr(obj_1, 'attr_1'))
# 'ExampleClass' object has no attribute 'attr_1'.
# print("getattr(obj_1, 'attr_1') ->", getattr(obj_1, 'attr_1'))

Здесь важно, что при обращении к атрибуту объекта, созданного на основе класса, интерпретатор
производит поиск этого атрибута сначала в самом объекте, а затем, при отсутствии
такового, во всех классах, расположенных выше в дереве наследования в "базовых" классах
(в классах, от которых данный класс наследуется).

# Пример №4. Атрибуты классов и объектов в python (часть 2).
# Создаем класс без методов.
class ExampleClass:
    # Атрибут данных класса (доступен всем экземплярам).
    attr_0 = 0

# Создаем 1-й экземпляр класса ExampleClass.
obj_1 = ExampleClass()

# Выведет 0, т.е. значение атрибута класса.
print('obj_1.attr_0 ->', obj_1.attr_0)

# Определяем (изменяем) значение атрибута в экземпляре.
obj_1.attr_0 = 1
# Выведет 1, т.е. значение атрибута этого экземпляра.
print('obj_1.attr_0 ->', obj_1.attr_0)

# Удаляем атрибут attr_0 экземпляра (но не класса).
del obj_1.attr_0
# Выведет True, т.к. интерпретатор совершит поиск атрибута
# в дереве наследования и найдет его в объекте класса.
print("hasattr(obj_1, 'attr_0') ->", hasattr(obj_1, 'attr_0'))
# Выведет 0, т.е. значение атрибута класса.
print('obj_1.attr_0 ->', obj_1.attr_0)

# Получим ошибку, т.к. удалять в объекте нечего.
# del obj_1.attr_0

Даже при отсутствии атрибута непосредственно в самом экземпляре, интерпретатор НЕ ВОЗБУЖДАЕТ
ошибку, а сперва пытается отыскать его в самом классе. Поэтому даже после удаления атрибута
attr_0 в объекте (экземпляре) obj_1 при повторной попытке обращения к нему через obj_1.attr_0
интерпретатор  не выдаёт ошибки, а возвращает значение общедоступного атрибута, найденного в
объекте класса ExampleClass.

Получить доступ или посмотреть текущий набор атрибутов класса или объекта можно при помощи
ранее упомянутого СЛОВАРЯ АТРИБУТОВ object.__dict__.
__dict__ - это специальный атрибут в каждом модуле. Он представляет собой словарь,
или другой объект сопоставления, используемый для хранения атрибутов. Он содержит таблицу
символов модуля, которая динамически изменяется в процессе изменения как количества доступных
атрибутов, так и их значений.

# Пример №5. Атрибуты классов и объектов в python (часть 3).
# Создаем класс.
class A:
    # Атрибут данных класса.
    attr_1 = 1
    # Атрибут-метод.
    def set_attr(self):
        self.attr_2 = 2

# Словарь с атрибутами объекта класса.
print('Атрибуты класса:', A.__dict__)

# Создаем экземпляр класса A.
obj = A()
# Словарь с атрибутами экземпляра.
print('Атрибуты экземпляра:', obj.__dict__)

# Установим атрибут экземпляру.
obj.set_attr()
# Проверим словарь.
print('Атрибуты экземпляра:', obj.__dict__)

# Изменим значение атрибута.
obj.attr_2 = 2.1
# Добавим еще один атрибут.
obj.attr_3 = 3
# Проверим словарь.
print('Атрибуты экземпляра:', obj.__dict__)

# Изменим значение атрибута через словарь.
obj.__dict__['attr_3'] = 3.1
# Удалим атрибут через словарь.
del obj.__dict__['attr_2']
# Проверим словарь.
print('Атрибуты экземпляра:', obj.__dict__)
# Выведем измененное значение атрибута.
print(obj.__dict__['attr_3'])
# Но обычный способ проще.
print(obj.attr_3)


Поскольку в python объекты присутствуют повсюду, атрибут __dict__ имеется не только у классов,
но и у других объектов, например, объектов функций (!!!).

Статические методы и методы класса
Обычные атрибуты-методы классов в момент своего вызова в качестве первого аргумента
автоматически получают ссылку на объект класса, посредством которого они вызываются.
Такие методы формально называют методами объектов (экземпляров), поскольку они предполагают
воздействие на объекты экземпляров класса (!!!).
В python присутствуют еще две разновидности методов:
методы классов, которые при вызове в качестве первого аргумента вместо объекта экземпляра
автоматически получают ОБЪЕКТ САМОГО КЛАССА,
а также статические методы, которые представляют собой обычные функции, определенные
внутри класса и не требующие передачи экземпляра (объекта) класса в качестве первого
аргумента.

Для получения таких методов служат встроенные функции
classmethod(method) и staticmethod(method),
которые необходимо вызывать внутри классов. Обе функции помечают переданный объект метода
method как специальный, т.е. требующий передачи объекта самого класса для метода класса и,
соответственно, не требующий передачи экземпляра (объекта) класса для статического метода.

# Пример №6. Виды методов в классах (часть 1).
# Определяется класс.
class Cls:

    # Обычный метод экземпляра.
    def object_method(self):
        print('Object')

    # Метод класса.
    def class_method(cls):
        print('Class')

    # Статический метод.
    def static_method():
        print('Static')

    # Теперь под cls подразумевается объект
    # самого класса Cls, а не его экземпляра.
    class_method = classmethod(class_method)

    # Теперь метод при вызове не будет
    # автоматически запрашивать экземпляр.
    static_method = staticmethod(static_method)

# Создаем экземпляр класса.
obj = Cls()

# Методу экземпляра в качестве первого аргумента
# автоматически передается экземпляр класса.
obj.object_method()
# Или передаем вручную при вызове из класса.
Cls.object_method(obj)

# Метод класса автоматически получает объект
# самого класса Cls вместо его экземпляра obj.
obj.class_method()
# При вызове из класса передавать его не нужно.
Cls.class_method()

# Статический метод вызывается как обычная ф-ция,
# ничего не знающая ни о классе, ни о его экз-ре.
obj.static_method()
Cls.static_method()

Объявить статический метод или метод класса можно объявить через встроенные декораторы:
обе функции classmethod(method) и staticmethod(method) позволяют использовать синтаксис
декораторов. для этого перед определениями нужных методов записываются строки
@classmethod и @staticmethod.

# Пример №7. Виды методов в классах (часть 2).
# Определяем класс.
class Cls:

    # Обычный метод экземпляра.
    def object_method(self):
        print('Object')

    @classmethod
    def class_method(cls):
        print('Class')

    @staticmethod
    def static_method():
        print('Static')

# Создаем экземпляр класса.
obj = Cls()

# Вызываем методы.
obj.object_method()
Cls.object_method(obj)

obj.class_method()
Cls.class_method()

obj.static_method()
Cls.static_method()

Методы экземпляра предназначены для обработки данных каждого отдельного экземпляра класса,
а методы класса обрабатывают данные самого класса, являющиеся общими сразу для всех экземпляров
этого класса.
Например, методы класса могут использоваться для подсчета созданных (объектов) экземпляров
класса, вести список экземпляров, находящихся в данный момент в оперативной памяти,
изменять существующие или устанавливать новые атрибуты-данных класса.
Кроме того, если первый аргумент методов экземпляра при определении принято обозначать
через self и его нужно передавать явным образом при вызове через класс,
то для первого аргумента методов класса принято использовать имя cls, НЕ УКАЗЫВАЯ его явным
образом как при вызове из экземпляров, так и вызове через сам класс.

Статические методы как и методы класса предназначены для работы с атрибутами класса,
а не атрибутами экземпляра (объекта). Но при этом они НЕ предполагают автоматической
передачи в качестве первого аргумента объекта класса. Поэтому статические методы могут
быть использованы как самые обычные функции, выполняющие какие-либо полезные действия
так или иначе связанные с данными класса и определенные в его пространстве имен для более
тесной связи с классом, а также уменьшения вероятности конфликта имен в глобальной области
видимости.
Более того, их можно даже не объявлять статическими при помощи функции staticmethod(method).
В таком случае они останутся доступны посредством объекта класса, но станут недоступны для
вызовов из экземпляров класса.

# Пример №8. Виды методов в классах (часть 3).
# Определяем класс.
class Cls:

    # Атрибут данных класса используем
    # как счетчик экземпляров, созданных
    # за все время работы программы.
    num_obj = 0

    # Конструктор класса.
    def __init__(self):
        # Вызывается каждый раз при
        # создании нового экземпляра.
        self.increase_counter()

    @classmethod
    def increase_counter(cls):
        # +1 экземпляр.
        cls.num_obj += 1

    # Просто функция для вывода. Объявляется при помощи функции
    # staticmethod(method), которая представлена декоратором
    @staticmethod
    def print_num_obj():
        print(Cls.num_obj)

# Создаем экземпляры класса,
# попутно выводя кол-во экземпляров.
obj1 = Cls()
Cls.print_num_obj()
obj2 = Cls()
Cls.print_num_obj()

obj3 = Cls()
# Статический метод можно вызывать
# также из любого экземпляра.
obj3.print_num_obj()

Можно было бы определить функцию print_num_objects() и вне класса, при этом она по прежнему
выполняла бы свою работу, но тогда она выглядела бы обособленной от класса
(особенно для других программистов, читающих этот код), нарушая при этом принцип инкапсуляции
и "захломляя" глобальное пространство имен модуля.

Инкапсуляция в классах
Как указываллось ранее, по умолчанию все атрибуты и методы класса являются ОТКРЫТЫМИ или
ПУБЛИЧНЫМИ (от англ. public).
Это значит, что они доступны не только внутри класса, но и за его пределами. Для этого
достаточно использовать синтаксис доступа к атрибутам при помощи точки (например, obj.attr)
или предназначенные для этого встроенные функции (например, getattr(obj, 'attr')).
Однако бывают случаи, когда требуется ограничить прямой доступ к атрибутам классов из
вызывающего кода во избежание передачи им некорректных значений или случайного удаления.
Примером может служить расстояние между железнодорожными станциями, которое не может быть
отрицательным, или значение атрибута, предназначенного для служебного пользования.
В таких случаях атрибуты объявляются закрытыми или приватными (от англ. private), предоставляя
доступ к ним посредством интерфейсов взаимодействия в виде специальных методов, осуществляющих
необходимые проверки передаваемых им значений. Важно, что при этом в python инкапсуляция в
классах (т.е. сокрытие данных) поддерживается лишь на уровне соглашения между программистами.
Полностью скрыть реализацию класса от целенаправленных действий извне не получится.

Так атрибуты, предназначенные для внутреннего использования, принято начинать с одного символа
подчеркивания (например, _var). Встретив такой атрибут, другой программист будет иметь в виду,
что он не предназначен для публичного использования и в дальнейшем может быть даже удален
без предварительного уведомления. В тоже время никто не запрещает изменять такой атрибут
надеясь, что это не повлияет на работоспособность класса.

# Пример №9. Инкапсуляция в классах (часть 1).
# Определяем класс числа Пи.
class NumPi:

    # Атрибут для служебного пользования.
    # Точность числа Пи по умолчанию.
    _pi = 3.141592

    # Атрибут-метод экземпляра.
    def round_pi(self, d):
        # Уст-вает экз-ру требуемую точностью Пи.
        self._pi = round(NumPi._pi, d)

# Создаем экземпляр класса.
pi_obj =  NumPi()
# Атрибут доступен для чтения по имени.
print('pi =', pi_obj._pi)

# Установим требуемую точность.
pi_obj.round_pi(3)
print('pi =', pi_obj._pi)

# Атрибут доступен и для изменения.
pi_obj._pi = 0
# Не стоило этого делать.
print('pi =', pi_obj._pi)


Если нужна большая защищенность атрибута, нужно указывать в начале его имени ДВА(!!!) знака
подчеркивания в формате __attr_name. В результате такой манипуляции атрибут останется доступен
внутри класса, но станет недоступен по такому имени за его пределами, так как вне класса имена
атрибутов, начинающихся с двух знаков подчеркивания, автоматически преобразуются интерпретатором
из формата __attr_name в формат _Class__attr_name (хотя бы какая-то реализация защищенности атрибута).

# Пример №10. Инкапсуляция в классах (часть 2).
# Определение обычного класса.
class Person:

    # Обычный открытый атрибут данных класса.
    company = '«Okpython»'

    # Открытый (публичный) атрибут-метод.
    def set_name(self, name):
        # Создаем атрибут данных экземпляра.
        self.name = name

    # Открытый (публичный) атрибут-метод.
    def get_name(self):
        # Используем атрибут данных экземпляра.
        return self.name

    # Закрытый (приватный) атрибут-метод.
    def __check_age(self, age):
        # Проверяем возраст сотрудника.
        if 18 < age < 75:
            # Создаем атрибут данных экземпляра.
            self.__age = age
        else:
            # Выводим предупреждение.
            print('Недопустимый возраст!')

    # Открытый метод.
    def set_age(self, age):
        # Внутри класса и объектов метод доступен.
       self.__check_age(age)

    # Открытый метод.
    def get_age(self):
        # Используем атрибут данных экземпляра.
        return self.__age

# Создаем экземпляр класса.
person =  Person()
# Добавляем имя сотрудника.
person.set_name('Егор')
# Добавляем возраст сотрудника.
person.set_age(25)

# Получаем имя сотрудника.
print('Имя сотрудника:', person.get_name())
# Тоже самое, т.к. атрибут открыт.
print('Имя сотрудника:', person.name, end='\n\n')

# Получаем возраст сотрудника.
print('Возраст сотрудника:', person.get_age())
# 'Person' object has no attribute '__age'.
# print(person.__age)
# 'Person' object has no attribute '__check_age'.
# person.__check_age()
# Но всегда можно использовать полное имя.
print('Возраст сотрудника:', person._Person__age)


Таким образом, атрибуты, в именах которых присутствует приставка с двумя символами подчеркивания,
действительно недоступны напрямую по своему имени за пределами класса. Тем не менее, они также не
обеспечивают НАСТОЯЩЕГО сокрытия данных, т.к. зная имя вмещающего класса всегда можно обратиться к
таким атрибутам по их расширенному имени в формате _Class__attr_name из любой точки программы, где
имеется ссылка на экземпляр (объект) класса.

Однако способ реального контроля за доступом к важным атрибутам класса python все-таки предоставляется.
Делается это при помощи встроенной функции
property(fget=None, fset=None, fdel=None, doc=None)
, которая позволяет создать свойство класса или, по-другому, управляемый атрибут.
Функция принимает четыре аргумента со значениями по умолчанию None:

fget – объект функции, которая будет вызываться при попытке прочитать значение атрибута и
       возвращать вычисленное значение атрибута;
fset – объект функции, которая будет вызываться при попытке выполнить операцию присваивания;
fdel – объект функции, которая будет вызываться при попытке удаления атрибута;
doc – строка документирования с описанием атрибута, если это необходимо.

Результатом вызова функции property является объект свойства, присваиваемый имени атрибута,
которым требуется управлять и который будет находиться в области видимости класса и наследоваться
всеми его экземплярами.

# Пример №11. Инкапсуляция в классах (часть 3).
# Определяем обычный класс.
class Age:

    # Вызывается при попытке обращения к атрибуту.
    def get_age(self):
        # Возвращаем значение возраста.
        return self._age

    # Вызывается при попытке установки атрибута.
    def set_age(self, age):
        # Проверяем возраст сотрудника.
        if 18 < age < 75:
            # Создаем атрибут данных экземпляра.
            self._age = age
        else:
            # Выводим предупреждение.
            print('Недопустимый возраст!')

    # Вызывается при попытке удаления атрибута.
    def del_age(self):
        # Просто выводим предупреждение.
        print('Удаление невозможно!')

    # Документация управляемого атрибута.
    s_age = 'Удаление запрещено!'

    # Организуем управление атрибутом.
    age = property(get_age, set_age, del_age, doc=s_age)

# Создаем экземпляр класса.
person_age =  Age()

# Вызовет set_age и выведет предупреждение.
person_age.age = 100
# А здесь все в норме.
person_age.age = 25
# Можно по-прежнему напрямую.
person_age.set_age(25)

# Вызовет get_age.
print('Возраст:', person_age.age)
# Или можно вызвать напрямую.
print('Возраст:', person_age.get_age())

# Попытка удаления атрибута.
del person_age.age


В этом примере создан класс с управляемым атрибутом age. Благодаря этому, при каждой попытке обращения
к нему по имени person_age.age будет вызываться один из предназначенных для его управления методов.
Именно поэтому атрибут остался доступен для чтения, но стал недоступен для удаления. При этом, во
избежание конфликта имен, сохраняются данные в атрибуте с именем _age, так как само имя age было
зарезервировано для хранения объекта свойства, возвращаемого функцией property.

Если необходимо запретить изменение значения атрибута или даже сделать его полностью закрытым для
доступа из кода за пределами класса, нужно ВСЕГО ЛИШЬ (!!!) изменить поведение отвечающих за это методов,
переданных функции property в качестве аргументов.

# Пример №12. Инкапсуляция в классах (часть 4).
# Определяем класс числа Пи.
class NumPi:

    # Атрибут для служебного пользования.
    # Точность числа Пи по умолчанию.
    _pi = 3.141592

    # Передаем требуемую точность для экз-ра.
    def __init__(self, d):
        # Уст-вает экз-ру требуемую точностью Пи.
        self._pi = round(NumPi._pi, d)

    # Вызывается при попытке обращения к атрибуту.
    def get_pi(self):
        # Возвращаем значение Пи.
        return self._pi

    # Вызывается при попытке установки атрибута.
    def set_pi(self, pi_val):
        # Выводим предупреждение.
        print('Изменение запрещено!')

    # Вызывается при попытке удаления атрибута.
    def del_pi(self):
        # Просто выводим предупреждение.
        print('Удаление невозможно!')

    # Документация управляемого атрибута.
    s_pi = 'Только чтение!'

    # Организуем управление атрибутом.
    pi = property(get_pi, set_pi, del_pi, doc=s_pi)

# Создаем экземпляр класса.
pi_obj =  NumPi(3)

# Атрибут доступен для чтения.
print('pi =', pi_obj.pi)
# Но недоступен для изменения.
pi_obj.pi = 0
# И удаления.
del pi_obj.pi


При этом объект свойства, возвращаемый функцией property обладает атрибутами-методами
getter(get_method),
setter(set_method) и
deleter(del_method),
которые позволяют определить соответствующие методы для обработки обращений к управляемому атрибуту.
При этом первый метод практически никогда не используется, т.к. вызов функции property() уже
подразумевает его передачу в качестве первого аргумента.

# Пример №13. Инкапсуляция в классах (часть 5).

# Определяем класс числа Пи.
class NumPi:

    # Атрибут для служебного пользования.
    # Точность числа Пи по умолчанию.
    _pi = 3.141592

    # Передаем требуемую точность для экз-ра.
    def __init__(self, d):
        # Уст-вает экз-ру требуемую точностью Пи.
        self._pi = round(NumPi._pi, d)

    # Вызывается при попытке обращения к атрибуту.
    def pi(self):
        # Возвращаем значение Пи.
        return self._pi

    # Вызывается при попытке установки атрибута.
    def set_pi(self, pi_val):
        # Выводим предупреждение.
        print('Изменение запрещено!')

    # Вызывается при попытке удаления атрибута.
    def del_pi(self):
        # Просто выводим предупреждение.
        print('Удаление невозможно!')

    # Документация управляемого атрибута.
    s_pi = 'Только чтение!'

    # Организуем управление атрибутом.
    pi = property(pi, doc=s_pi)
    pi = pi.setter(set_pi)
    pi = pi.deleter(del_pi)

# Выводим документацию.
print(NumPi.pi.__doc__)

# Создаем экземпляр класса.
pi_obj =  NumPi(3)
# Атрибут доступен для чтения.
print('pi =', pi_obj.pi)
# Но недоступен для изменения.
pi_obj.pi = 0
# И удаления.
del pi_obj.pi

Опять же, весь процесс можно осуществить при помощи декораторов, которые делают код
более простым (!!!) (!!!) и приятным (!!!) для восприятия.

# Пример №14. Инкапсуляция в классах (часть 6).
# Определяем класс числа Пи.
class NumPi:

    # Атрибут для служебного пользования.
    # Точность числа Пи по умолчанию.
    _pi = 3.141592

    # Передаем требуемую точность для экз-ра.
    def __init__(self, d):
        # Уст-вает экз-ру требуемую точностью Пи.
        self._pi = round(NumPi._pi, d)

    # Аналог pi = property(pi, doc='Чтение!').
    @property
    # Вызывается при попытке обращения к атрибуту.
    def pi(self):
        '''Чтение!'''
        # Возвращаем значение Пи.
        return self._pi

    # при использовании декораторов декорируемые методы должны иметь одно
    # и то же имя, иначе интерпретатор возбудит исключение.

    # Аналог инструкции pi = pi.setter(pi).
    @pi.setter
    # Вызывается при попытке установки атрибута.
    def pi(self, pi_val):
        # Выводим предупреждение.
        print('Изменение запрещено!')

    # Аналог инструкции pi = pi.deleter(pi).
    @pi.deleter
    # Вызывается при попытке удаления атрибута.
    def pi(self):
        # Просто выводим предупреждение.
        print('Удаление невозможно!')

    # ====================================================================

# Выводим документацию.
print('О числе:', NumPi.pi.__doc__)

# Создаем экземпляр класса.
pi_obj = NumPi(3)
# Атрибут доступен для чтения.
print('pi =', pi_obj.pi)
# Но недоступен для изменения.
pi_obj.pi = 0
# И удаления.
del pi_obj.pi

Важно, что при использовании декораторов декорируемые методы должны иметь одно и то же имя,
иначе интерпретатор возбудит исключение.

Наследование классов
Наследование позволяет создавать новый класс, называемый подклассом, на основе уже существующего класса,
называемого суперклассом. Более того, в python поддерживается механизм множественного наследования,
при котором подкласс может наследовать атрибуты и методы сразу нескольких суперклассов.
Все что нужно, это перечислить наследуемые суперклассы в порядке их приоритета в скобках в
заголовке инструкции class.

# Пример №15. Наследование классов в python (часть 1).
# Создаем 1-й суперкласс.
class Super_1:

    # Атрибут данных класса.
    attr_0 = 0.1
    # Атрибут данных класса.
    attr_1 = 1

    # Конструктор 1-го суперкласса.
    def __init__(self):
        self.p_1 = '«Конструктор 1-го суперкласса.»'

    # Атрибут-метод в 1-м суперклассе.
    def method_1(self):
        print('«method_1»')


# Создаем 2-й суперкласс.
class Super_2:

    # Атрибут данных класса.
    attr_0 = 0.2
    # Атрибут данных класса.
    attr_2 = 2

    # Конструктор 2-го суперкласса.
    def __init__(self):
        self.p_2 = '«Конструктор 2-го суперкласса.»'

    # Атрибут-метод во 2-м суперклассе.
    def method_2(self):
        print('«method_2»')


# Создаем подкласс, наследуя оба суперкласса.
class Sub_3(Super_1, Super_2):

    # Атрибут данных подкласса.
    attr_3 = 3

    # Атрибут-метод в подклассе.
    def method_3(self):
        print('«method_3»')


# Создаем экземпляр подкласса Sub_3.
obj = Sub_3()

# Выведет 1 (атрибут унаследован от 1-го суперкласса).
print('obj.attr_1 ->', obj.attr_1)
# Выведет 2 (атрибут унаследован от 2-го суперкласса).
print('obj.attr_2 ->', obj.attr_2)
# Выведет 3 (значение собственного атрибута).
print('obj.attr_3 ->', obj.attr_3)
# Выведет 0.2, т.к. атрибут был найден в скобках в 1-м
# суперклассе (поиск в скобках идет слева направо).
print('obj.attr_0 ->', obj.attr_0)

# Выведет «method_1» (метод унасл. от 1-го суперкласса).
obj.method_1()
# Выведет «method_2» (метод унасл. от 2-го суперкласса).
obj.method_2()
# Выведет «method_3» (собственный метод).
obj.method_3()

# Выведет «Конструктор 1-го суперкласса.», т.к.
# конструктор был найден в скобках в 1-м суперклассе.
print('obj.p_1 ->', obj.p_1)
# 'Sub_3' object has no attribute 'p_2', т.к.
# конструктор 2-го суперкласса не вызывался.
print('obj.p_2 ->', obj.p_2)


В том же примере подкласс Sub_3 наследует атрибуты сразу двух суперклассов Super_1 и Super_2.
Однако поскольку оба суперкласса обладают атрибутом с именем attr_0, интерпретатор выбрал
для подкласса значение атрибута суперкласса Super_1, т.к. при наследовании поиск атрибутов ведется
сперва в самом подклассе, а затем в списке наследуемых суперклассов слева направо.
Именно поэтому подкласс Sub_3 унаследовал конструктор первого суперкласса. Если бы понадобилось отдать
приоритет атрибутам второго суперкласса, его пришлось бы перечислить в скобках первым
(ну очень просто !!!).

Помимо того, что подклассы наследуют данные и методы своих суперклассов, они могут определять и
свои собственные атрибуты. Так в подклассе Sub_3 были определены собственный атрибут данных attr_3 и
метод method_3. При необходимости подклассы могут изменять (специализировать) наследуемые атрибуты или
даже полностью замещать их.

Код РезультатpythonCodes
# Создаем суперкласс.
class SuperClass:

    # Атрибут данных класса.
    attr_1 = 1

    # Конструктор суперкласса.
    def __init__(self):
        self.p_1 = '«Конструктор суперкласса.»'

    # 1-й метод в суперклассе.
    def method_1(self):
        print('«method_1 в суперклассе»')

    # 2-й метод в суперклассе.
    def method_2(self):
        print('«method_2»')


# Пример №16. Наследование классов в python (часть 2).
class SubClass(SuperClass):

    # Меняем значение атрибута в подклассе.
    attr_1 = 2

    # Определяем собственный атрибут данных подкласса.
    attr_3 = 3

    # Переопределяем (расширяем) конструктор.
    def __init__(self):
        # Вызываем конструктор суперкласса.
        SuperClass.__init__(self)
        # Добавляем для экземпляра свой атрибут.
        self.p_2 = '«Конструктор подкласса.»'

    # Переопределяем (расширяем) метод суперкласса.
    def method_2(self):
        # Вызываем исходный метод суперкласса.
        SuperClass.method_2(self)
        # Добавляем собственную функциональность.
        print('«method_2+»')

    # Собственный метод в подклассе.
    def method_3(self):
        print('«method_3 в подклассе»')


# Создаем экземпляр подкласса SubClass.
obj = SubClass()
# Выведет 2, т.к. атрибут был переопределен в подклассе.
print('obj.attr_1 ->', obj.attr_1)
# Выведет «Конструктор суперкласса.».
print('obj.p_1 ->', obj.p_1)
# Выведет «Конструктор подкласса.».
print('obj.p_2 ->', obj.p_2)
# «method_1 суперкласса» (метод унасл. от суперкласса).
obj.method_1()
# «method_2» и «method_2+» (метод расширен в подклассе).
obj.method_2()
# «method_3 подкласса» (собственный метод).
obj.method_3()

Следует заметить, что в ходе специализации методов в подклассах внутри замещающего метода обычно
предусматривается вызов исходной версии метода наследуемого суперкласса.
Это позволяет выполнить предусмотренный в суперклассе набор действий по умолчанию без необходимости
повторного написания уже имеющегося кода. Так в подклассе SubClass примера был расширен конструктор
и метод method_2 суперкласса. В результате были вызваны исходные версии методов вместо того,
чтобы заново переписывать их код.

Доступ к оригинальным методам так же может быть получен не только напрямую через имя суперкласса,
но и через встроенную функцию super([type[, object-or-type]]), возвращающую специальный
объект-посредник, делегирующий вызовы метода суперклассу указанного типа type.
В качестве необязательных аргументов она принимает тип (т.е. объект подкласса), для которого будет
производиться поиск суперкласса, а также конкретный объект экземпляра подкласса или объект самого
подкласса, для которого требуется получить доступ к методу.

# Пример №17. Наследование классов в python (часть 3).
# Создаем суперкласс.
class A:

    # Статический метод суперкласса.
    def method_0():
        print('«method_0 in class A»')

    # 1-й метод в суперклассе.
    def method_1(self):
        print('«method_1 in class A»')

    # 2-й метод в суперклассе.
    def method_2(self):
        print('«method_2 in class A»')

# Наследует суперкласс A.
class B(A):
    # Расширяем 1-й метод из суперкласса A.
    def method_1(self):
        # Используем метод из суперкласса A.
        # Можно и через super().method_1().
        super(B, self).method_1()
        # Своя функциональность.
        print('«method_1 in class B»')

# Наследует суперкласс B.
class C(B):
    # Расширяем 2-й метод из суперкласса A.
    def method_2(self):
        # Используем метод из суперкласса A.
        super(B, self).method_2()
        # Своя функциональность.
        print('«method_2 in class C»')

# Создаем экземпляр подкласса C.
obj = C()
# «method_1 in class A» и «method_1 in class B».
obj.method_1()
# «method_2 in class A» и «method_2 in class C».
obj.method_2()

# Вызываем вне класса, указав подкласс для которого
# ищем суперкласс с методом, а также целевой объект.
# Выведет «method_1 in class A».
super(B, obj).method_1()
# «method_0 in class A» (указали объект класса).
super(B, C).method_0()


Функция super() может вызываться из подкласса без аргументов. В таком случае интерпретатор автоматически
использует в качестве аргументов текущий подкласс и объект self. Кроме того, ее можно вызывать и вне
классов, явно передавая требуемый тип и целевой объект.

Описание ситуации, когда подкласс наследует сразу несколько суперклассов с одинаковыми именами атрибутов.
Выше уже указывалось, что в таком случае подклассом будет унаследовано значение атрибута того суперкласса,
который перечисляется в заголовке инструкции class первым.
Но что делать, когда важны значения атрибутов ВСЕХ классов? В этом случае, чтобы гарантировать
принадлежность атрибута тому классу, который его использует, необходимо в начале имени атрибута
поставить два символа подчеркивания везде, где оно используется этим классом.

# Пример №18. Наследование классов в python (часть 4).
# 1-й суперкласс.
class A:

    # Устанавливаем экземпляру атрибуты.
    def set_a(self):
        # Обычный атрибут.
        self.x = 1
        # y искажается в _A__y.
        self.__y = 1

    # Получаем атрибуты.
    def get_a(self):
        print(self.x)
        print(self.__y)

# 2-й суперкласс.
class B:

    # Устанавливаем экземпляру атрибуты.
    def set_b(self):
        # Обычный атрибут.
        self.x = 2
        # y искажается в _B__y.
        self.__y = 2

    # Получаем атрибуты.
    def get_b(self):
        print(self.x)
        print(self.__y)

# Просто наследует 2 суперкласса.
class C(A, B): pass

# Создаем объект подкласса.
obj = C()

# Теперь obj.x == 1 и _A__y == 1.
obj.set_a()
# obj.x переопределен на 2 и _B__y == 2.
obj.set_b()

# Посмотрим его словарь атрибутов.
# {'x': 2, '_A__y': 1, '_B__y': 2}.
print(obj.__dict__)

# Выведет 2 (x) и 1 (_A__y).
obj.get_a()
# Выведет 2 (x) и 2 (_B__y).
obj.get_b()

В примере благодаря наличию приставки из двух знаков подчеркивания атрибуты остались доступны по
короткому имени внутри класса, но стали недоступны вне класса, так как имена этих атрибутов были
дополнены интерпретатором именами их классов до _A__y и _B__y, что и показал словарь атрибутов
obj.__dict__ после вызова методов obj.set_a() и obj.set_b().
При этом атрибут x, который использовался без спецприставки, был методом obj.set_b() перезаписан.

Композиция классов
Композиция классов – это еще один принцип ООП, использующийся в python и предоставляющий возможность
создания классов, включающих в себя вызовы уже существующих классов.

# Пример №19. Композиция классов в python.
# Создаем 1-й класс-донор.
class Компания:
    # Конструктор класса.
    def __init__(self, название):
        # Определяем название компании.
        self.название = название

    # Устанавливаем юр. адрес компании.
    def уст_адрес(self, адрес):
        self.адрес = адрес

# Создаем 2-й класс-донор.
class Площадь:
    # Расчет площади прямоугольника.
    def рассчитать_площадь_прям(self, a, b):
        self.площадь_прямоугольника = a*b

    # Расчет площади круга.
    def рассчитать_площадь_круга(self, r):
        self.площадь_круга = 3.14*r**2

# Создаем класс-агрегатор.
class Магазин:
    # Конструктор класса.
    def __init__(self, компания, номер):
        # Интерфейс для работы с данными компании.
        self.компания = Компания(компания)
        # Определяем номер магазина.
        self.номер = номер

    # Устанавливаем время работы магазина.
    def уст_время_работы(self, время='8.00 - 23.00'):
        self.время_работы = время

    # Рассчитываем площадь магазина.
    def уст_площадь_магазина(self, a, b):
        # Интерфейс для расчета площади магазина.
        площадь = Площадь()
        площадь.рассчитать_площадь_прям(a, b)
        self.площадь_магазина = площадь.площадь_прямоугольника

# Создаем экземпляр магазина.
маг_1 = Магазин('Простор', 1)
# Уст. время работы магазина.
маг_1.уст_время_работы('9.30 - 22.00')
# Рассчитаем площадь магазина.
маг_1.уст_площадь_магазина(50, 70)

# Выводим информацию о магазине.
print('Компания: «{}»'.format(маг_1.компания.название))
print('Магазин: №', маг_1.номер, sep='')
print('Площадь магазина: {}м'.format(маг_1.площадь_магазина))
print('Время работы:', маг_1.время_работы)


В этом примере были использованы вызовы классов Компания и Площадь внутри класса Магазин,
использовав реализации их интерфейсов, т.е. готовые экземпляры этих классов, для получения
требуемых возможностей: имени компании и метода для расчета площади прямоугольника.

Таким образом, композиция представляет собой еще одну концепцию повторного использования программного
кода, предполагающую формирование целого из частей, при котором класс-контейнер использует внутри себя
экземпляры других классов-доноров, и выступая в качестве контролера их интерфейсов.
Такой подход бывает полезным в крупных системах, в которых множественное наследование большого
числа классов может приводить к определенным трудностям, а также в случаях, когда нужно повторно
использовать лишь небольшую часть возможностей базового класса (как в нашем примере).

Магические методы и перегрузка операторов
Перегрузка операторов в python представляет собой процесс перехватывания встроенных операций при
помощи специальных методов классов, называемых магическими методами.
Все магические методы имеют специальные имена, начинающиеся и заканчивающиеся двумя символами
подчеркивания, что отличает их от других имен, которые обычно определяются в классах.
Встречая такие методы, интерпретатор автоматически вызывает их при выполнении соответствующих
встроенных операций над экземплярами классов, воспринимая возвращаемые ими значения как результаты
этих операций.

Перегрузка операторов позволяет классам участвовать в обычных операциях,
делая экземпляры классов более похожими на представителей встроенных типов данных.
Достигается такой эффект за счет того, что магические методы позволяют перегружать все операторы
выражений, а также такие операции, как ввод и вывод, вызов функций, обращение к атрибутам и многие
другие операции.

# Пример №20. Перегрузка операторов в python.
# Определяем класс.
class Num:

    # Конструктор класса - один из
    # самых известных методов перегрузки.
    def __init__(self, start_data):
        # Начальное значение экземпляра.
        self.data = start_data

    # Метод перегрузки операции вычитания.
    def __sub__(self, n):
        # Для целых чисел.
        if isinstance(n, int):
            # Создаем и возвр. новый экземпляр,
            # изменяя хранимое в нем число.
            return Num(self.data - n)
        # Для других объектов этого типа.
        elif isinstance(n, Num):
            # Вычитаем хранимые значения.
            return Num(self.data - n.data)
        # Для других объектов.
        else:
            print('Операция не поддерживается!')

# При создании экземпляров класса интерпретатор
# автоматически вызывает конструктор класса.
a = Num(25)
b = Num(10)

# А здесь интерпретатор автоматически вызывает
# спец. метод реализации операции вычитания.
c = a - b
# Выводим результат операции на экран.
print('a - b =', c.data)

# Для целых чисел.
d = a - 5
# Выведет 20.
print('a - 5 =', d.data)

# Вещественные числа не поддерживаются.
d = a - 5.7

# Магический метод __add__ не переопределен!
# unsupported operand type(s) for +: 'Num' and 'int'.
d = a + 5


В примере юыли использованы два метода перегрузки, имеющихся в python:
конструктор класса __init__, а также
метод __sub__, который отвечает за операцию вычитания.

Последний метод был использовн для того, чтобы экземпляры созданного типа Num могли использоваться
в операции вычитания целых чисел и других экземпляров этого типа.
Все магические методы могут свободно наследоваться от суперклассов и переопределяться в подклассах,
как и любые другие методы. Если же какой-то метод не реализован в классе, это лишь означает, что
соответствующая ему операция не поддерживается данным классом, а попытка применения такой операции
будет возбуждать исключение (что мы и увидели при попытке выполнить инструкцию d = a + 5,
содержащую операцию сложения экземпляра a нового типа Num с целым числом).

Перечисление наиболее часто используемые магические методы:
__add__ (сложение),
__sub__ (вычитание),
__mul__ (умножение),
__truediv__ (деление),
__mod__ (остаток от деления),
__pow__ (возведение в степень),
__and__ (логическое И),
__or__ (логическое ИЛИ),
__getattr__ (обращение к атрибуту),
__setattr__ (присваивание атрибуту),
__delattr__ (удаление атрибута),
__getitem__ (доступ к элементу по индексу, извлечение среза, итерации),
__setitem__ (присваивание элементу по индексу или срезу),
__delitem__ (удаление среза или элемента по индексу),
__len__ (длина),
__bool__ (проверка логического значения),
__lt__ (меньше),
__gt__ (больше),
__le__ (меньше или равно),
__ge__ (больше или равно),
__eq__ (равно),
__ne__ (не равно),
__iter__ (получение итератора),
__iadd__ (комбинированный оператор сложения),
__next__ (получение следующего элемента итератора),
__contains__ (оператор проверки на вхождение in),
__new__ (создание объекта),
__init__ (конструктор),

__del__ (деструктор), __call__ (вызов функции) и др.

Значительно большее количество имеющихся магических методов можно найти, например, на официальном сайте
python в разделе Data model справочного руководства.

Абстрактные классы и методы
Абстрактный класс – это класс, содержащий один или несколько абстрактных методов, то есть объявленных,
но не реализованных методов.

Абстрактный класс не может использоваться для создания экземпляров.
Для этого он должен быть сперва унаследован, а все его абстрактные методы реализованы.
Только тогда полученный подкласс можно будет использовать для получения экземпляров,
в противном случае будет возбуждено исключение.

# Пример №21. Определение абстрактных классов в python.
# Импортируем класс и декоратор.
from abc import ABC, abstractmethod

# Определяем абстрактный суперкласс.
class Animal(ABC):
    # Определяем абстрактный метод.
    @abstractmethod
    def make_sound(self):
        pass

# Определяем подкласс кошек.
class Cat(Animal):
    # Реализуем абстрактный метод для кошек.
    def make_sound(self):
        return "Мяу"

# Определяем подкласс собак.
class Dog(Animal):
    # Реализуем абстрактный метод для собак.
    def make_sound(self):
        return "Гав"

# Определяем подкласс коров.
class Cow(Animal):
    # Собственный метод (абстрактный не реализован!).
    def set_owner(self, owner):
        self.owner = owner

# Создаем экземпляр класса кошек.
cat = Cat()
# Мяукаем.
print('Кошки говорят "{}"!'.format(cat.make_sound()))

# Создаем экземпляр класса собак.
dog = Dog()
# Гавкаем.
print('Собаки говорят "{}"!'.format(dog.make_sound()))

try:
    # Пытаемся создать экземпляр абстрактного класса.
    animal = Animal()
except Exception as err:
    # Can't instantiate abstract class Animal with
    # abstract method make_sound/
    print(err)

try:
    # Пытаемся создать экземпляр класса Cow, в
    # котором мы забыли реализовать абстрактный метод.
    cow = Cow()
except Exception as err:
    # Can't instantiate abstract class Cow with
    # abstract method make_sound.
    print(err)

Таким образом, создать абстрактный класс в python довольно просто: нужно всего лишь импортировать
из модуля abc стандартной библиотеки метакласс ABC и декоратор abstractmethod, после чего унаследовать
метакласс создаваемым абстрактным классом, попутно помечая декоратором методы, которые необходимо
сделать абстрактными. Далее необходимо реализовать абстрактные методы в создаваемых подклассах,
иначе интерпретатор возбуит соответствующие исключения.

Абстрактные методы могут быть реализованы и в самом абстрактном классе.
Однако в любом случае в создаваемом подклассе все они должны быть либо полностью переопределены,
либо дополнены в соответствии с правилами обычного наследования.

# Пример №22. Переопределение абстрактных методов в подклассах.
# Импортируем класс и декоратор.
from abc import ABC, abstractmethod

# Определяем абстрактный суперкласс.
class Animal(ABC):
    # Определяем абстрактный метод.
    @abstractmethod
    def make_sound(self):
        self.s = 'Питомец говорит "{}"!'

# Определяем подкласс кошек.
class Cat(Animal):
    # Реализуем абстрактный метод для кошек.
    def make_sound(self):
        # Вызываем сперва родительский метод.
        # Animal.make_sound(self)
        super().make_sound()
        return self.s.format('Мяу')

# Определяем подкласс собак.
class Dog(Animal):
    # Реализуем абстрактный метод для собак.
    def make_sound(self):
        # Полностью переопределяем абстр. метод.
        s = 'Собаки говорят "{}"!'.format('Гав')
        return s

# Создаем экземпляр класса кошек.
cat = Cat()
# Мяукаем.
print(cat.make_sound())

# Создаем экземпляр класса собак.
dog = Dog()
# Гавкаем.
print(dog.make_sound())


Таким образом, как и другие концепции объектно-ориентированного программирования,
абстрактные классы служат для улучшения качества архитектуры приложения (???),
позволяют уменьшить объем работы (???) и облегчают дальнейшую поддержку кода.

Конструкторы и деструкторы
Итак, конструктор представляет собой магический метод, который автоматически вызывается при
создании каждого нового экземпляра класса, в котором он определен. Это позволяет передавать
вновь создаваемым экземплярам начальные данные, тем самым инициализируя некоторое состояние объекта
ещё до начала его использования.
Для объявления конструкторов используется метод с именем __init__, изменять которое запрещается.
Далее, если созданные объекты после выполнения своего предназначения становятся ненужными,
имеет смысл удалять их для высвобождения памяти. В python для этих целей имеется автоматический сборщик
мусора, удаляющий объекты, которые выходят за пределы текущей области видимости или счетчики ссылок
на которые становятся равными нулю. Кроме того, ненужные объекты можно удалять и самостоятельно,
используя, например, инструкцию del. В любом случае, если ссылок на объект больше не остается,
интерпретатор вызывает деструктор – еще один магический метод с именем __del__, представляющий собой
операцию окончательного удаления объектов. Используются деструкторы реже конструкторов,
но в некоторых ситуациях их применение бывает оправданным.
Так деструкторы обычно определяют в классах, для которых перед стандартным удалением требуется
выполнить еще какие-нибудь действия, например, закрыть файл или соединение с базой данных.

# Пример №23. Конструкторы и деструкторы в python.
# Определяем класс.
class Budget:

    # Конструктор класса инициализирует
    # экземпляр начальными данными.
    def __init__(self, сумма=100000):
        # Создаем атрибут данных экземпляра.
        self.сумма = сумма

    # Деструктор класса запускается автоматически
    # после удаления всех ссылок на объект.
    def __del__(self):
        # Перед удалением выводим сообщение.
        print('Бюджет успешно распилен!')

# Создаем экземпляр класса.
городской_бюджет_1 = Budget(1000000)
# Получаем еще одну ссылку на объект.
городской_бюджет_2 = городской_бюджет_1
# Счетчик ссылок на объект уменьшается на 1.
del городской_бюджет_1
# А вот здесь уже будет вызван деструктор.
del городской_бюджет_2


Важно, что инструкция del obj не вызывает напрямую метод obj.__del__(),
она лишь уменьшает счетчик ссылок для соответствующего объекта на единицу.
И только тогда, когда счетчик полностью обнуляется, интерпретатор использует
деструктор для окончательной зачистки следов существования ненужного объекта в памяти.

Итоги
Класс – это шаблон кода, который используется для описания структуры и создания объектов,
то есть экземпляров этого класса.
python обладает всеми преимуществами абстрактного подхода в программировании.
В частности ему присущи:
полиморфизм – способность функций и методов обрабатывать данные разных типов;
инкапсуляция – механизм, который позволяет объединять данные и методы,
               работающие с этими данными, в единый объект, скрывая при этом
               детали реализации от пользователя;
наследование – еще одна концепция объектно-ориентированного программирования,
               которая позволяет на основе одного суперкласса создавать
               множественные подклассы, заимствующие его данные и функциональность с
               возможностью их изменения и добавления своих данных и функциональности;
композиция (агрегирование) – возможность создания классов, включающих в себя вызовы
                             уже существующих классов.

Процедура создания класса в простейшем случае сводится к объявлению имени класса в заголовке
инструкции class и перечислению в теле класса его атрибутов, состоящих из атрибутов данных и
атрибутов-методов.
Что касается создания экземпляров класса (объекта), то делается это по аналогии с вызовами
обычной функции, т.е. при помощи пары круглых скобок после имени класса в формате
ClassName(arg_1, arg_2, ... arg_n).

Доступ к открытому атрибуту вне класса или объекта может быть получен с помощью имени этого
атрибута, указанного через точку после имени класса или объекта в формате obj.attr.
Для добавления нового атрибута или изменения значения уже существующего используется привычная
нам инструкция присваивания obj.new_attr = value или, соответственно, obj.attr = new_value,
а удаление осуществляется инструкцией del obj.attr

Помимо синтаксиса с точкой операции над атрибутами объектов в python могут проводиться также
при помощи предназначенных для этого встроенных функций:
hasattr(object, name) – проверка наличия атрибута с именем name;
getattr(object, name[, default]) – получение значения атрибута name, если он существует;
setattr(object, name, value) – установка нового значения value атрибуту с именем name,
                               если он существует;
delattr(object, name) – удаление атрибута с именем name, если объект позволяет это сделать.

Получить доступ или посмотреть текущий набор атрибутов класса или его экземпляра (объекта)
можно еще и при помощи словаря атрибутов object.__dict__, который динамически изменяется в
процессе изменения как количества доступных атрибутов, так и их значений.

В python существуют три их основные разновидности методов:
- методы экземпляров (объектов), которые при вызове в качестве первого аргумента
  автоматически получают экземпляр класса, посредством которого они вызываются;
- методы классов, которые при вызове в качестве первого аргумента вместо  экземпляра (объекта)
  автоматически получают объект самого класса;
- статические методы, которые представляют собой обычные функции, определенные внутри класса
  и не требующие передачи экземпляра класса в качестве первого аргумента.

Для создания методов классов и статических методов применяются встроенные функции
classmethod(method) и
staticmethod(method),
которые необходимо вызывать внутри классов либо использовать в качестве декораторов.

По умолчанию все атрибуты и методы класса являются открытыми. Но если необходимо пометить
атрибут в качестве предназначенного для служебного пользования, его следует начинать с одного
знака подчеркивания, например, _name. При этом атрибут все равно останется доступным
вне класса по его имени, но, по крайней мере, те, кого это касается (другие программисты),
будут знать о его статусе (его принадлежности для служебного пользования).
Для большей защиты от изменений извне можно использовать два (!!!) символа нижнего
подчеркивания, например, __name. В этом случае атрибут станет недоступен вне класса по
его имени, т.к. оно будет искажено интерпретатором до формата _Class__name.
При этом данный способ защиты от изменений извне НЕ обеспечивает настоящего сокрытия данных,
т.к. зная имя вмещающего класса всегда можно обратиться к таким атрибутам по их расширенному
имени _Class__attr_name из любой точки программы, где имеется ссылка на экземпляр класса.

Кроме того, реальный контроль за доступом к важным атрибутам класса предоставляет встроенная
функция
property(fget=None, fset=None, fdel=None, doc=None),
которая возвращает объект свойства, присваиваемый имени атрибута, которым требуется
управлять и который будет находиться в области видимости класса и наследоваться всеми его
экземплярами. Благодаря использованию этой функции при попытке доступа к атрибуту по его имени
будет вызываться один из методов, передаваемых ей в качестве аргументов.
Вызываться функция должна внутри класса.
При этом разрешается использовать ее в качестве декоратора, что делает код более
компактным(!!!) и читабельным(???).

В python поддерживается механизм множественного наследования, при котором подкласс может
наследовать атрибуты и методы сразу нескольких суперклассов.
Все что нужно, это перечислить наследуемые суперклассы в порядке их приоритета в скобках
в заголовке объявления класса (инструкции class). При этом подклассы не только наследуют
данные и методы своих суперклассов, но также могут переопределять их или же определять
свои собственные атрибуты данных и методы.

Поиск унаследованных атрибутов выполняется сначала в объекте экземпляра, затем в классе,
из которого был создан экземпляр, и далее, по умолчанию, во всех суперклассах в направлении
снизу вверх и слева направо в дереве объектов.

Как только будет найдено первое вхождение атрибута, поиск прекращается.

В ходе наследования доступ к оригинальным методам может быть получен не только напрямую
через имя суперкласса SuperClass.method(), но также и через встроенную функцию
super([type[, object-or-type]]), возвращающую специальный объект-посредник,
делегирующий вызовы метода данного объекта экземпляра или подкласса суперклассу
указанного типа type.

Помимо наследования, которое обеспечивает передачу возможностей от одного класса другим классам
(его наследникам), передача возможностей (свойств и методов) от одних классов другим,
обеспечивается посредством композиции, которая подразумевает использование в определении
класса вызовов других классов. В результате получаемые экземпляры (объекты) класса
как бы собираются из экземпляров других классов, реализуя подход формирования целого из частей.
Такой подход бывает полезным в крупных системах, в которых множественное наследование большого
количества классов может приводить к определенным трудностям, а также в случаях, когда
нужно повторно использовать лишь небольшую часть возможностей базового класса.

Еще одной возможностью, которая python предоставляется в классах, является перегрузка
операторов посредством МАГИЧЕСКИХ методов, которые позволяют перегружать все операторы
выражений, а также такие операции, как
ввод и вывод,
вызов функций,
обращение к атрибутам и
т.д.

Благодаря этому классы могут участвовать в обычных операциях, что делает их более похожими
на встроенные типы.
Также доступна в python возможность использования абстрактных классов, то есть классов,
содержащих один или несколько абстрактных методов. Важно при этом, что они не могут
использоваться для создания экземпляров (объектов).
Для этого абстрактный класс должен быть сперва унаследован, а все его абстрактные методы
реализованы. Только после этого полученный подкласс можно использовать для получения
экземпляров (объектов), в противном случае будет возбуждено исключение.
Если созданные объекты после выполнения своего предназначения становятся ненужными,
интерпретатор задействует автоматический сборщик мусора, вызывающий деструктор __del__
для окончательного удаления объектов. Обычно это происходит, когда объект выходит за
пределы текущей области видимости или счетчик ссылок на него становится равным нулю.
